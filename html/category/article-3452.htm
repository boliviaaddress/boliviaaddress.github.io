<!doctype html>
<html lang="zh-CN">

<head>
        <link rel="canonical" href="https://boliviaaddress.github.io/html/category/article-3452.htm" />
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>ASP.NET Core WebApi返回结果统一包装实践 - Bolivia Address</title>
    <link rel="icon" href="/assets/addons/xcblog/img/boliviaaddress/favicon.ico" type="image/x-icon"/>
        <!-- google-fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- //google-fonts -->
    <!-- Template CSS Style link -->
    <link rel="stylesheet" href="/assets/addons/xcblog/css/boliviaaddress/style-starter.css">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?48ec1baacefae763d2c0b3b6955a6c32";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body>
    <!--header-->
    <header id="site-header" class="fixed-top">
        <div class="container-fluid">
            <nav class="navbar navbar-expand-lg stroke">
                                <a class="navbar-brand d-flex align-items-center" href="/">
                        Bolivia Address</a>
                                
                <button class="navbar-toggler  collapsed bg-gradient" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon fa icon-expand fa-bars"></span>
                    <span class="navbar-toggler-icon fa icon-close fa-times"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
                    <ul class="navbar-nav ml-lg-auto">
                                                <li class="nav-item">
                            <a class="nav-link" href="/">首页</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/html/category/">文章分类</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="#">关于</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">联系</a>
                        </li>

                    </ul>
                </div>
                <!-- toggle switch for light and dark theme -->
                <div class="cont-ser-position">
                    <nav class="navigation">
                        <div class="theme-switch-wrapper">
                            <label class="theme-switch" for="checkbox">
                                <input type="checkbox" id="checkbox">
                                <div class="mode-container">
                                    <i class="gg-sun"></i>
                                    <i class="gg-moon"></i>
                                </div>
                            </label>
                        </div>
                    </nav>
                </div>
                <!-- //toggle switch for light and dark theme -->
            </nav>
        </div>
    </header>
    <!--//header-->
    <!-- inner banner -->
    <div class="inner-banner">
        <section class="w3l-breadcrumb">
            <div class="container">
                <h1 class="inner-text-title font-weight-bold text-white mb-sm-3 mb-2" style="line-height: 3rem;word-break: break-all;">ASP.NET Core WebApi返回结果统一包装实践</h1>
                <ul class="breadcrumbs-custom-path">
                    <li><a href="/">首页</a></li>
                    <li><span class="fa fa-chevron-right mx-2" aria-hidden="true"></span><a href="/html/category/">文章分类</a></li>
                    <li class="active"><span class="fa fa-chevron-right mx-2" aria-hidden="true"></span>正文</li>
                </ul>
            </div>
        </section>
    </div>
    <!-- //inner banner -->
    <!-- about section -->
    <section class="video-section py-5">
        <div class="container py-md-5 py-4">
            <div class="row">
                <div class="col-md-9">
                      				  				  				<h3 id="前言">前言</h3> <p>&nbsp;&nbsp;&nbsp;&nbsp;近期在重新搭建一套基于ASP.NET Core WebAPI的框架，这其中确实带来了不少的收获，毕竟当你想搭建一套框架的时候，你总会不自觉的去想，如何让这套框架变得更完善一点更好用一点。其中在关于WebApi统一结果返回的时候，让我也有了更一步的思考，首先是如何能更好的限制返回统一的格式，其次是关于结果的包装一定是更简单更强大。在不断的思考和完善中，终于有了初步的成果，便分享出来，学无止境思考便无止境，希望以此能与君共勉。</p> <h3 id="统一结果类封装">统一结果类封装</h3> <p>&nbsp;&nbsp;&nbsp;&nbsp;首先如果让返回的结果格式统一，就得有一个统一的包装类去包装所有的返回结果，因为返回的具体数据虽然格式一致，但是具体的值的类型是不确定的，因此我们这里需要定义个泛型类。当然如果你不选择泛型类的话用dynamic或者object类型也是可以的,但是这样的话可能会带来两点不足</p> <ul> <li>一是可能会存在装箱拆箱的操作。</li> <li>二是如果引入swagger的话是没办法生成返回的类型的，因为dynamic或object类型都是执行具体的action时才能确定返回类型的，但是swagger的结构是首次运行的时候就获取到的，因此无法感知具体类型。</li> </ul> <h4 id="定义包装类">定义包装类</h4> <p>上面我们也说了关于定义泛型类的优势，这里就话不多说来直接封装一个结果返回的包装类</p> <pre><code class="language-csharp">public class ResponseResult&lt;T&gt; {     /// &lt;summary&gt;     /// 状态结果     /// &lt;/summary&gt;     public ResultStatus Status { get; set; } = ResultStatus.Success;      private string? _msg;      /// &lt;summary&gt;     /// 消息描述     /// &lt;/summary&gt;     public string? Message     {         get         {             // 如果没有自定义的结果描述，则可以获取当前状态的描述             return !string.IsNullOrEmpty(_msg) ? _msg : EnumHelper.GetDescription(Status);         }         set         {             _msg = value;         }     }      /// &lt;summary&gt;     /// 返回结果     /// &lt;/summary&gt;     public T Data { get; set; } }</code></pre> <p>其中这里的<code>ResultStatus</code>是一个枚举类型，用于定义具体的返回状态码，用于判断返回的结果是正常还是异常或者其他，我这里只是简单的定义了一个最简单的示例，有需要的话也可以自行扩展</p> <pre><code class="language-csharp">public enum ResultStatus {     [Description("请求成功")]     Success = 1,     [Description("请求失败")]     Fail = 0,     [Description("请求异常")]     Error = -1 }</code></pre> <p>这种情况下定义枚举类型并且结合它的<code>DescriptionAttribute</code>的特性去描述枚举的含义是一个不错的选择，首先它可以统一管理每个状态的含义，其次是更方便的获取每个状态对应的描述。这样的话如果没有自定义的结果描述，则可以获取当前状态的描述来充当默认值的情况。这个时候在写具体action的时候会是以下的效果</p> <pre><code class="language-csharp">[HttpGet("GetWeatherForecast")] public ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetAll() {     var datas = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast     {         Date = DateTime.Now.AddDays(index),         TemperatureC = Random.Shared.Next(-20, 55),         Summary = Summaries[Random.Shared.Next(Summaries.Length)]     });     return new ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; {  Data = datas }; }</code></pre> <p>这样的话每次编写action的时候都可以返回一个<code>ResponseResult&lt;T&gt;</code>的结果了，这里就体现出了使用枚举定义状态码的优势了，相当一部分场景我们可以省略了状态码甚至是消息的编写，毕竟很多时候在保障功能的情况下，代码还是越简介越好的，更何况是一些高频操作呢。</p> <h4 id="升级一下操作">升级一下操作</h4> <p>上面虽然我们定义了<code>ResponseResult&lt;T&gt;</code>来统一包装返回结果，但是每次还得new一下，在无疑是不太方便的，而且还要每次都还得给属性赋值啥的，也是够麻烦的，这个时候就想，如果能有相关的辅助方法去简化操作就好了，方法不用太多能满足场景就好，也就是够用就好，最主要的是能支持扩展就可以。因此，进一步升级一下结果包装类，来简化一下操作</p> <pre><code class="language-csharp">public class ResponseResult&lt;T&gt; {     /// &lt;summary&gt;     /// 状态结果     /// &lt;/summary&gt;     public ResultStatus Status { get; set; } = ResultStatus.Success;      private string? _msg;      /// &lt;summary&gt;     /// 消息描述     /// &lt;/summary&gt;     public string? Message     {         get         {             return !string.IsNullOrEmpty(_msg) ? _msg : EnumHelper.GetDescription(Status);         }         set         {             _msg = value;         }     }      /// &lt;summary&gt;     /// 返回结果     /// &lt;/summary&gt;     public T Data { get; set; }      /// &lt;summary&gt;     /// 成功状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="result"&gt;返回的数据&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     public static ResponseResult&lt;T&gt; SuccessResult(T data)     {         return new ResponseResult&lt;T&gt; { Status = ResultStatus.Success, Data = data };     }      /// &lt;summary&gt;     /// 失败状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="code"&gt;状态码&lt;/param&gt;     /// &lt;param name="msg"&gt;失败信息&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     public static ResponseResult&lt;T&gt; FailResult(string? msg = null)     {         return new ResponseResult&lt;T&gt; { Status = ResultStatus.Fail, Message = msg };     }      /// &lt;summary&gt;     /// 异常状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="code"&gt;状态码&lt;/param&gt;     /// &lt;param name="msg"&gt;异常信息&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     public static ResponseResult&lt;T&gt; ErrorResult(string? msg = null)     {         return new ResponseResult&lt;T&gt; { Status = ResultStatus.Error, Message = msg };     }      /// &lt;summary&gt;     /// 自定义状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="status"&gt;&lt;/param&gt;     /// &lt;param name="result"&gt;&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     public static ResponseResult&lt;T&gt; Result(ResultStatus status, T data, string? msg = null)     {         return new ResponseResult&lt;T&gt; { Status = status, Data = data, Message = msg };     } }</code></pre> <p>这里进一步封装了几个方法，至于具体封装几个这种方法，还是那句话够用就好，这里我封装了几个常用的操作，成功状态、失败状态、异常状态、最完全状态，这几种状态基本上可以满足大多数的场景，不够的话可以自行进行进一步的多封装几个方法。这样的话在action使用的时候就会简化很多,省去了手动属性赋值</p> <pre><code class="language-csharp">[HttpGet("GetWeatherForecast")] public ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetAll() {     var datas = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast     {         Date = DateTime.Now.AddDays(index),         TemperatureC = Random.Shared.Next(-20, 55),         Summary = Summaries[Random.Shared.Next(Summaries.Length)]     });     return ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt;.SuccessResult(datas); }</code></pre> <h4 id="进一步完善">进一步完善</h4> <p>上面我们通过完善<code>ResponseResult&lt;T&gt;</code>类的封装，确实在某些程度上节省了一部分操作，但是还是有点美中不足，那就是每次返回结果的时候，虽然定义了几个常用的静态方法去操作返回结果，但是每次还得通过手动去把<code>ResponseResult&lt;T&gt;</code>类给请出来才能使用，现在呢想在操作返回结果的时候不想看到它了。这个呢也很简单，我们可以借助微软针对MVC的Controller的封装进一步得到一个思路，那就是定义一个基类的Controller，我们在Controller基类中，把常用的返回结果封装一些方法，这样在Controller的子类中呢就可以直接调用这些方法，而不需要关注如何去编写方法的返回类型了，话不多说动手把Controller基类封装起来</p> <pre><code class="language-csharp">[ApiController] [Route("api/[controller]")] public class ApiControllerBase : ControllerBase {     /// &lt;summary&gt;     /// 成功状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="result"&gt;返回的数据&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     protected ResponseResult&lt;T&gt; SuccessResult&lt;T&gt;(T result)     {         return ResponseResult&lt;T&gt;.SuccessResult(result);     }      /// &lt;summary&gt;     /// 失败状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="code"&gt;状态码&lt;/param&gt;     /// &lt;param name="msg"&gt;失败信息&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     protected ResponseResult&lt;T&gt; FailResult&lt;T&gt;(string? msg = null)     {         return ResponseResult&lt;T&gt;.FailResult(msg);     }      /// &lt;summary&gt;     /// 异常状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="code"&gt;状态码&lt;/param&gt;     /// &lt;param name="msg"&gt;异常信息&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     protected ResponseResult&lt;T&gt; ErrorResult&lt;T&gt;(string? msg = null)     {         return ResponseResult&lt;T&gt;.ErrorResult(msg);     }      /// &lt;summary&gt;     /// 自定义状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="status"&gt;&lt;/param&gt;     /// &lt;param name="result"&gt;&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     protected ResponseResult&lt;T&gt; Result&lt;T&gt;(ResultStatus status, T result, string? msg = null)     {         return ResponseResult&lt;T&gt;.Result(status, result, msg);     } }</code></pre> <p>有了这么一个大神的辅助，一切似乎又向着美好进发了一步，这样的话每次我们自定义的Controller可以继承<code>ApiControllerBase</code>类，从而使用里面的简化操作。所以再写起来代码，大概是这么一个效果</p> <pre><code class="language-csharp">public class WeatherForecastController : ApiControllerBase {     private static readonly string[] Summaries = new[]     {        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"     };      [HttpGet("GetWeatherForecast")]     public ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetAll()     {         var datas = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast         {             Date = DateTime.Now.AddDays(index),             TemperatureC = Random.Shared.Next(-20, 55),             Summary = Summaries[Random.Shared.Next(Summaries.Length)]         });         return SuccessResult(datas);     } }</code></pre> <p>这个时候确实变得很美好了，但是还是没有逃脱一点，那就是我还是得通过特定的方法来得到一个<code>ResponseResult&lt;T&gt;</code>类型的返回结果，包括我们给<code>ResponseResult&lt;T&gt;</code>类封装静态方法，或者甚至是定义<code>ApiControllerBase</code>基类，都是为了进一步简化这个操作。现在呢我想告别这个限制，我能不能把返回的结果直接就默认的转化成<code>ResponseResult&lt;T&gt;</code>类型的结果呢？当然可以，这也是通过ASP.NET Core的封装思路中得到的启发，借助<code>implicit</code>自动完成隐式转换，这个在ASP.NET Core的<code>ActionResult&lt;T&gt;</code>类中也有体现</p> <pre><code class="language-csharp">public static implicit operator ActionResult&lt;TValue&gt;(TValue value) {     return new ActionResult&lt;TValue&gt;(value); }</code></pre> <p>通过这个思路我们可以进一步完善<code>ResponseResult&lt;T&gt;</code>类的实现方式，给它添加一个隐式转换的操作，仅仅定义一个方法即可，在<code>ResponseResult&lt;T&gt;</code>类中继续完善</p> <pre><code class="language-csharp">/// &lt;summary&gt; /// 隐式将T转化为ResponseResult&lt;T&gt; /// &lt;/summary&gt; /// &lt;param name="value"&gt;&lt;/param&gt; public static implicit operator ResponseResult&lt;T&gt;(T value) {     return new ResponseResult&lt;T&gt; { Data = value }; }</code></pre> <p>这种对于绝大部分返回成功结果的时候提供了非常简化的操作，这个时候如果你再去使用action的时候就可以进一步来简化返回值的操作了</p> <pre><code class="language-csharp">[HttpGet("GetWeatherForecast")] public ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetAll() {     var datas = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast     {         Date = DateTime.Now.AddDays(index),         TemperatureC = Random.Shared.Next(-20, 55),         Summary = Summaries[Random.Shared.Next(Summaries.Length)]     });     return datas.ToList(); }</code></pre> <p>因为我们定义了<code>T</code>到<code>ResponseResult&lt;T&gt;</code>的隐式转换，所以这个时候我们就可以直接返回结果了，而不需要手动对结果返回值进行包装。</p> <h3 id="漏网之鱼处理">漏网之鱼处理</h3> <p>在上面我们为了尽量简化action返回<code>ResponseResult&lt;T&gt;</code>的统一返回结构的封装，已经对<code>ResponseResult&lt;T&gt;</code>类进行了许多的封装，并且还通过封装<code>ApiControllerBase</code>基类进一步简化这一操作，但是终究还是避免不了一点，那就是很多时候可能想不起来对action的返回值去加<code>ResponseResult&lt;T&gt;</code>类型的返回值，但是我们之前的所有封装都得建立在必须要声明<code>ResponseResult&lt;T&gt;</code>类型的返回值的基础上才行，否则就不存在统一返回格式这一说法了。所以针对这些漏网之鱼，我们必须要有统一的拦截机制，这样才能更完整的针对返回结果进行处理，针对这种对action返回值的操作，我们首先想到的就是定义<code>过滤器</code>进行处理，因此笔者针对这一现象封装了一个统一包装结果的过滤器，实现如下</p> <pre><code class="language-csharp">public class ResultWrapperFilter : ActionFilterAttribute {     public override void OnResultExecuting(ResultExecutingContext context)     {         var controllerActionDescriptor = context.ActionDescriptor as ControllerActionDescriptor;         var actionWrapper = controllerActionDescriptor?.MethodInfo.GetCustomAttributes(typeof(NoWrapperAttribute), false).FirstOrDefault();         var controllerWrapper = controllerActionDescriptor?.ControllerTypeInfo.GetCustomAttributes(typeof(NoWrapperAttribute), false).FirstOrDefault();         //如果包含NoWrapperAttribute则说明不需要对返回结果进行包装，直接返回原始值         if (actionWrapper != null || controllerWrapper != null)         {             return;         }          //根据实际需求进行具体实现         var rspResult = new ResponseResult&lt;object&gt;();         if (context.Result is ObjectResult)         {             var objectResult = context.Result as ObjectResult;             if (objectResult?.Value == null)             {                 rspResult.Status = ResultStatus.Fail;                 rspResult.Message = "未找到资源";                 context.Result = new ObjectResult(rspResult);             }             else             {                 //如果返回结果已经是ResponseResult&lt;T&gt;类型的则不需要进行再次包装了                 if (objectResult.DeclaredType.IsGenericType &amp;&amp; objectResult.DeclaredType?.GetGenericTypeDefinition() == typeof(ResponseResult&lt;&gt;))                 {                     return;                 }                 rspResult.Data = objectResult.Value;                 context.Result = new ObjectResult(rspResult);             }             return;         }     } }</code></pre> <p>在使用WebAPI的过程中，我们的action绝大部分是直接返回<code>ViewModel</code>或<code>Dto</code>而并没有返回<code>ActionResult</code>类型相关，但是无妨，这个时候MVC的底层操作会为我们将这些自定义的类型包装成<code>ObjectResult</code>类型的，因此我们的<code>ResultWrapperFilter</code>过滤器也是通过这一机制进行操作的。这里有两点需要考虑的</p> <ul> <li>首先是，我们必须要允许并非所有的返回结果都要进行<code>ResponseResult&lt;T&gt;</code>的包装，为了满足这一需求我们还定义了<code>NoWrapperAttribute</code>来实现这一效果，只要Controller或Action有<code>NoWrapperAttribute</code>的修饰则不对返回结果进行任何处理。</li> <li>其次是，如果我们的Action上的返回类型已经是<code>ResponseResult&lt;T&gt;</code>类型的，则也不需要对返回结果进行再次的包装。</li> </ul> <p>关于<code>ResultWrapperFilter</code>的定义其实很简单，因为在这里它只是起到了一个标记的作用</p> <pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class NoWrapperAttribute:Attribute { }</code></pre> <p>到了这里，还有一种特殊的情况需要注意，那就是当程序发生异常的时候，我们上面的这些机制也是没有办法生效的，因此我们还需要定义一个针对全局异常处理的拦截机制，同样是可以使用统一异常处理过滤器进行操作，实现如下</p> <pre><code class="language-csharp">public class GlobalExceptionFilter : IExceptionFilter {     private readonly ILogger&lt;GlobalExceptionFilter&gt; _logger;     public GlobalExceptionFilter(ILogger&lt;GlobalExceptionFilter&gt; logger)     {         _logger = logger;     }      public void OnException(ExceptionContext context)     {         //异常返回结果包装         var rspResult = ResponseResult&lt;object&gt;.ErrorResult(context.Exception.Message);         //日志记录         _logger.LogError(context.Exception, context.Exception.Message);         context.ExceptionHandled = true;         context.Result = new InternalServerErrorObjectResult(rspResult);     }      public class InternalServerErrorObjectResult : ObjectResult     {         public InternalServerErrorObjectResult(object value) : base(value)         {             StatusCode = StatusCodes.Status500InternalServerError;         }     } }</code></pre> <p>写完过滤器了，千万不能忘了全局注册一下，否则它也就只能看看了，不会起到任何效果</p> <pre><code class="language-csharp">builder.Services.AddControllers(options =&gt; {     options.Filters.Add&lt;ResultWrapperFilter&gt;();     options.Filters.Add&lt;GlobalExceptionFilter&gt;(); });</code></pre> <h3 id="漏网之鱼另一种处理">漏网之鱼另一种处理</h3> <p>当然针对上面两种针对漏网之鱼的处理，在ASP.NET Core上还可以通过中间件的方式进行处理，至于过滤器和中间件有何不同，相信大家已经非常清楚了，核心不同总结起来就一句话<code>二者的处理阶段不同，即针对管道的生命周期处理是不一样的，中间件可以处理任何生命周期在它之后的场景，但是过滤器只管理Controller这一块的一亩三分地</code>但是针对结果包装这一场景，笔者觉得使用过滤器的方式更容易处理一点，因为毕竟我们是要操作Action的返回结果，通过过滤器中我们可以直接拿到返回结果的值。但是这个操作如果在中间件里进行操作的话，只能通过读取<code>Response.Body</code>进行操作了，笔者这里也封装了一个操作，如下所示</p> <pre><code class="language-csharp">public static IApplicationBuilder UseResultWrapper(this IApplicationBuilder app) {         var serializerOptions = app.ApplicationServices.GetRequiredService&lt;IOptions&lt;JsonOptions&gt;&gt;().Value.JsonSerializerOptions;         serializerOptions.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;         return app.Use(async (context, next) =&gt;         {             var originalResponseBody = context.Response.Body;             try             {                 //因为Response.Body没办法进行直接读取，所以需要特殊操作一下                 using var swapStream = new MemoryStream();                 context.Response.Body = swapStream;                 await next();                 //判断是否出现了异常状态码，需要特殊处理                 if (context.Response.StatusCode == StatusCodes.Status500InternalServerError)                 {                     context.Response.Body.Seek(0, SeekOrigin.Begin);                     await swapStream.CopyToAsync(originalResponseBody);                     return;                 }                 var endpoint = context.Features.Get&lt;IEndpointFeature&gt;()?.Endpoint;                 if (endpoint != null)                 {                     //只针对application/json结果进行处理                     if (context.Response.ContentType.ToLower().Contains("application/json"))                     {                         //判断终结点是否包含NoWrapperAttribute                         NoWrapperAttribute noWrapper = endpoint.Metadata.GetMetadata&lt;NoWrapperAttribute&gt;();                         if (noWrapper != null)                         {                             context.Response.Body.Seek(0, SeekOrigin.Begin);                             await swapStream.CopyToAsync(originalResponseBody);                             return;                         }                         //获取Action的返回类型                         var controllerActionDescriptor = context.GetEndpoint()?.Metadata.GetMetadata&lt;ControllerActionDescriptor&gt;();                         if (controllerActionDescriptor != null)                         {                             //泛型的特殊处理                             var returnType = controllerActionDescriptor.MethodInfo.ReturnType;                             if (returnType.IsGenericType &amp;&amp; (returnType.GetGenericTypeDefinition() == typeof(Task&lt;&gt;) || returnType.GetGenericTypeDefinition() == typeof(ValueTask&lt;&gt;)))                             {                                 returnType = returnType.GetGenericArguments()[0];                             }                             //如果终结点已经是ResponseResult&lt;T&gt;则不进行包装处理                             if (returnType.IsGenericType &amp;&amp; returnType.GetGenericTypeDefinition() == typeof(ResponseResult&lt;&gt;))                             {                                 context.Response.Body.Seek(0, SeekOrigin.Begin);                                 await swapStream.CopyToAsync(originalResponseBody);                                 return;                             }                             context.Response.Body.Seek(0, SeekOrigin.Begin);                             //反序列化得到原始结果                             var result = await JsonSerializer.DeserializeAsync(context.Response.Body, returnType, serializerOptions);                             //对原始结果进行包装                             var bytes = JsonSerializer.SerializeToUtf8Bytes(ResponseResult&lt;object&gt;.SuccessResult(result), serializerOptions);                             new MemoryStream(bytes).CopyTo(originalResponseBody);                             return;                         }                     }                 }                 context.Response.Body.Seek(0, SeekOrigin.Begin);                 await swapStream.CopyToAsync(originalResponseBody);             }             finally             {                 //将原始的Body归还回来                 context.Response.Body = originalResponseBody;             }         });     } }</code></pre> <p>相信通过上面的处理，我们就可以更容易的看出来，谁更容易的对统一结果进行包装处理了，毕竟我们是针对Action的返回结果进行处理，而过滤器显然就是为针对Controller和Action的处理而生的。但是通过中间件的方式能更完整的针对结果进行处理，因为许多时候我们可能是在自定义的中间件里直接拦截请求并返回，但是根据二八原则这种情况相对于Action的返回值毕竟是少数，有这种情况我们可以通过直接<code>ResponseResult&lt;T&gt;</code>封装的方法进行返回操作，也很方便。但是这个时候呢，关于异常处理我们通过全局异常处理中间件，则能更多的处理更多的场景，且没有副作用，看一下它的定义</p> <pre><code class="language-csharp">public static IApplicationBuilder UseException(this IApplicationBuilder app) {     return app.UseExceptionHandler(configure =&gt;     {         configure.Run(async context =&gt;         {             var exceptionHandlerPathFeature = context.Features.Get&lt;IExceptionHandlerPathFeature&gt;();             var ex = exceptionHandlerPathFeature?.Error;             if (ex != null)             {                 var _logger = context.RequestServices.GetService&lt;ILogger&lt;IExceptionHandlerPathFeature&gt;&gt;();                 var rspResult = ResponseResult&lt;object&gt;.ErrorResult(ex.Message);                 _logger?.LogError(ex, message: ex.Message);                 context.Response.StatusCode = StatusCodes.Status500InternalServerError;                 context.Response.ContentType = "application/json;charset=utf-8";                 await context.Response.WriteAsync(rspResult.SerializeObject());             }         });     }); }</code></pre> <p>使用全局异常梳理中间件是没有副作用的，主要因为在异常处理的时候我们不需要读取<code>Response.Body</code>进行读取操作的，所以至于是选择异常处理中间件还是过滤器，大家可以针对自己的实际场景进行选择，两种方式都是可以的。</p> <h3 id="总结">总结</h3> <p>&nbsp;&nbsp;&nbsp;&nbsp;本文主要是展示了针对ASP.NET Core WeApi结果统一返回格式的相关操作，通过示例我们一步一步的展示了完成这一目标的不断升级的实现，虽然整体看起来比较简单，但是却承载着笔者一次又一次的思考升级。每次实现完一个阶段，都会去想有没有更好的方式去完善它。这其中还有一些思路来自微软源码为我们提供的思路，所以很多时候还是建议大家去看一看源码的，可以在很多时候为我们提供一种解决问题的思路。正如我看到的一句话，读源码也是一种围城，外面的人不想进去，里面的人不想出来。如果大家有更好的实现方式，欢迎一起讨论。曾经的时候我会为自己学到了一个新的技能而感到高兴，到了后来我会对有一个好的思路，或者好的解决问题的方法而感到高兴。读万卷书很重要，行万里路同样重要，读书是沉淀，行路是实践，结合到一起才能更好的促进，而不是只选择一种。</p> 			
                    <div class="col-md-12 mt-5">
                                                <p>上一个：<a href="/html/category/article-3451.htm">使用canvas制作验证码</a></p>
                                                <p>下一个：<a href="/html/category/article-3453.htm">pom.xml 报错org.apache.maven.plugin.war.WarMojo的解决办法</a></p>
                                            </div>

                                    </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/html/category/article-6868.htm" title="猫三联加狂犬疫苗多少钱（猫三联和狂犬疫苗一共多少钱）">猫三联加狂犬疫苗多少钱（猫三联和狂犬疫苗一共多少钱）</a></li>
                        <li class="py-2"><a href="/html/category/article-4392.htm" title="动物医院有公立的吗还是私立医院好呢（动物医院归哪里管）">动物医院有公立的吗还是私立医院好呢（动物医院归哪里管）</a></li>
                        <li class="py-2"><a href="/html/category/article-6173.htm" title="上海市青浦区第二中学分数线2023（青浦区二中最低分数线是多少）">上海市青浦区第二中学分数线2023（青浦区二中最低分数线是多少）</a></li>
                        <li class="py-2"><a href="/html/category/article-6869.htm" title="被宠物猫抓出血了有事吗（被宠物猫抓出血了有事吗）">被宠物猫抓出血了有事吗（被宠物猫抓出血了有事吗）</a></li>
                        <li class="py-2"><a href="/html/category/article-4426.htm" title="排名前十的兽药厂家（排名前十的兽药厂家名单）">排名前十的兽药厂家（排名前十的兽药厂家名单）</a></li>
                        <li class="py-2"><a href="/html/category/article-6684.htm" title="动物疫苗防疫站几点上班（动物疫苗防疫站几点上班的）">动物疫苗防疫站几点上班（动物疫苗防疫站几点上班的）</a></li>
                        <li class="py-2"><a href="/html/category/article-4467.htm" title="动物诊疗机构办理动物诊疗许可证需要多久 动物诊疗机构办理动物诊疗许可证需要多久">动物诊疗机构办理动物诊疗许可证需要多久 动物诊疗机构办理动物诊疗许可证需要多久</a></li>
                        <li class="py-2"><a href="/html/category/article-4609.htm" title="欢颜剧情介绍,演员表,角色介绍,剧集评价(欢颜剧情介绍,演员表,角色介绍,剧集评价语)">欢颜剧情介绍,演员表,角色介绍,剧集评价(欢颜剧情介绍,演员表,角色介绍,剧集评价语)</a></li>
                        <li class="py-2"><a href="/html/category/article-6777.htm" title="宠物用品都有哪些产品图片（宠物用品图片头像）">宠物用品都有哪些产品图片（宠物用品图片头像）</a></li>
                        <li class="py-2"><a href="/html/category/article-6040.htm" title="赤豆粥（赤豆粥图片）">赤豆粥（赤豆粥图片）</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">59</span> <a href="/html/date/2024-07/" title="2024-07 归档">2024-07</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-03/" title="2024-03 归档">2024-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">44</span> <a href="/html/date/2024-02/" title="2024-02 归档">2024-02</a></h4>
            </li>
                    </ul>
    </div>
</div>



                </div>
            </div>
        </div>
    </section>
    <!-- //about section -->
        <!-- footer -->
    <footer class="w3l-footer-22 position-relative mt-5 pt-5">
        
        <!-- copyright -->
        <div class="copyright-footer text-center">
            <div class="container">
                <div class="columns">
                    <p>Bolivia Address 版权所有</p>
                    <p>Powered by WordPress</p>
                </div>
            </div>
        </div>
        <!-- //copyright -->
    </footer>
    <!-- //footer -->
    <!-- Js scripts -->
    <!-- move top -->
    <button onclick="topFunction()" id="movetop" title="Go to top">
        <span class="fa fa-level-up" aria-hidden="true"></span>
    </button>
    <script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {
        scrollFunction()
    };

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("movetop").style.display = "block";
        } else {
            document.getElementById("movetop").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
    </script>
    <!-- //move top -->
    <!-- common jquery plugin -->
    <script src="/assets/addons/xcblog/js/frontend/boliviaaddress/jquery-3.3.1.min.js"></script>
    <!-- //common jquery plugin -->
    <!-- banner slider -->
    <script src="/assets/addons/xcblog/js/frontend/boliviaaddress/owl.carousel.js"></script>
    <script>
    $(document).ready(function() {
        $('.owl-one').owlCarousel({
            loop: true,
            margin: 0,
            nav: false,
            responsiveClass: true,
            autoplay: true,
            autoplayTimeout: 5000,
            autoplaySpeed: 1000,
            autoplayHoverPause: false,
            responsive: {
                0: {
                    items: 1,
                    nav: false
                },
                480: {
                    items: 1,
                    nav: false
                },
                667: {
                    items: 1,
                    nav: false
                },
                1000: {
                    items: 1,
                    nav: false
                }
            }
        })
    })
    </script>
    <!-- //banner slider -->
    <!-- counter for stats -->
    <script src="/assets/addons/xcblog/js/frontend/boliviaaddress/counter.js"></script>
    <!-- //counter for stats -->
    <!-- theme switch js (light and dark)-->
    <script src="/assets/addons/xcblog/js/frontend/boliviaaddress/theme-change.js"></script>
    <script>
    function autoType(elementClass, typingSpeed) {
        var thhis = $(elementClass);
        thhis.css({
            "position": "relative",
            "display": "inline-block"
        });
        thhis.prepend('<div class="cursor" style="right: initial; left:0;"></div>');
        thhis = thhis.find(".text-js");
        var text = thhis.text().trim().split('');
        var amntOfChars = text.length;
        var newString = "";
        thhis.text("|");
        setTimeout(function() {
            thhis.css("opacity", 1);
            thhis.prev().removeAttr("style");
            thhis.text("");
            for (var i = 0; i < amntOfChars; i++) {
                (function(i, char) {
                    setTimeout(function() {
                        newString += char;
                        thhis.text(newString);
                    }, i * typingSpeed);
                })(i + 1, text[i]);
            }
        }, 1500);
    }

    $(document).ready(function() {
        // Now to start autoTyping just call the autoType function with the 
        // class of outer div
        // The second paramter is the speed between each letter is typed.   
        autoType(".type-js", 200);
    });
    </script>
    <!-- //theme switch js (light and dark)-->
    <!-- MENU-JS -->
    <script>
    $(window).on("scroll", function() {
        var scroll = $(window).scrollTop();

        if (scroll >= 80) {
            $("#site-header").addClass("nav-fixed");
        } else {
            $("#site-header").removeClass("nav-fixed");
        }
    });

    //Main navigation Active Class Add Remove
    $(".navbar-toggler").on("click", function() {
        $("header").toggleClass("active");
    });
    $(document).on("ready", function() {
        if ($(window).width() > 991) {
            $("header").removeClass("active");
        }
        $(window).on("resize", function() {
            if ($(window).width() > 991) {
                $("header").removeClass("active");
            }
        });
    });
    </script>
    <!-- //MENU-JS -->
    <!-- disable body scroll which navbar is in active -->
    <script>
    $(function() {
        $('.navbar-toggler').click(function() {
            $('body').toggleClass('noscroll');
        })
    });
    </script>
    <!-- //disable body scroll which navbar is in active -->
    <!--bootstrap-->
    <script src="/assets/addons/xcblog/js/frontend/boliviaaddress/bootstrap.min.js"></script>
    <!-- //bootstrap-->
    <!-- //Js scripts -->
    <script>
    $(function() {
        $('.js_to').click(function(){
            var url = $(this).data('url');
            var code = $(this).data('code');
            url += code;

            window.open(url);
        })
    });
    </script>
</body>

</html>